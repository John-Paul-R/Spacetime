/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package origin;

import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.geom.Point2D;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedList;

import robocode.*;
import robocode.util.Utils;
public class Minigun extends AdvancedRobot {
    
    static LinkedList<EData> el;
    double sd=1;
    boolean scanned = false;
    double _x, _y, _w, _h;
    long _t;
    final static int _k = 20;
    double[] px=new double[_k], py=new double[_k];
    
    public void run() {
        setAdjustGunForRobotTurn(true);
		setAdjustRadarForGunTurn(true);
        setTurnRadarRightRadians(4*Math.PI);
        if (getRoundNum()<1)
        {
            el = new LinkedList<EData>();
            initKNN();
        }

        while(true)
        {
            _x=getX();
            _y=getY();
            _w=getBattleFieldWidth();
            _h=getBattleFieldHeight();
            _t=getTime();
            EData c = null;
            if (el.size()>0)
                c=el.getLast();
            if (el.size()>0 && el.size() < 100) {
                //System.out.println("["+getTime()+"] Firing with HOT");
                    //p=el.get(el.size()-2);
                    double a=Utils.normalRelativeAngle(c.ab-getGunHeadingRadians());
                    setTurnGunRightRadians(a);
                setFire(2.1);
            } else if (el.size()>100) {//Begin using knn gun
                //System.out.println("["+getTime()+"] Firing with KNN");
                long t=1;
                EData cState = c;
                ArrayList<EData> cStates = null;
                while (Rules.getBulletSpeed(2.1)*t < Point2D.distance(cState.x, cState.y, _x, _y))//predict into the future far enough (for a given bullet speed)
                {
                    try {
                        ArrayList<EData> ncStates = knnNext(_k, cState);
                        if (ncStates != null)
                        {
                            cStates = ncStates;
                        }
                        cState = ncStates.get(0);
                        cState = el.get(el.indexOf(cState)+1);
                    } catch (Exception e)
                    {
                        //System.out.println("["+getTime()+"] Hit list time boundary.");
                    }
                    
                    t++;
                    //System.out.println(t);
                }
                cStates = knnNext(_k, cState);
                for (int i=0; i < _k; i++)
                {
                    if (cStates != null)
                    {
                        px[i]=cStates.get(i).x;
                        py[i]=cStates.get(i).y;
                        System.out.println("test");
                    }
                    
                }
                
                double a=Utils.normalRelativeAngle(Math.atan2(cState.x-_x, cState.y-_y)-getGunHeadingRadians());
                setTurnGunRightRadians(a);
            }
            //System.out.println(c);
            if (!scanned)
            {
                System.out.println("Not scanned on turn " + getTime() +"!");
                setTurnGunRight(Rules.GUN_TURN_RATE);
                setTurnRadarRight(Rules.RADAR_TURN_RATE);
                setTurnRight(Rules.MAX_TURN_RATE);
            }
                
            scanned = false;
            setFire(2.1);
           execute();
        }
    }
    public void onPaint(Graphics2D g) {
        g.setColor(Color.RED);
        for (int i=0; i < _k; i++)
            g.drawOval((int)px[i]-18, (int)py[i]-18, 36, 36);
    }

    public void onScannedRobot(ScannedRobotEvent e) {
        if(el.size()>0) {
            el.add(new EData(e, el.getLast()));
        } else {
            el.add(new EData(e, null));
        }
        sd*=-1;
        double an = Utils.normalRelativeAngle(el.getLast().ab-getRadarHeadingRadians());
        setTurnRadarRightRadians(an+Math.signum(an)*Math.PI/8);
        //if (an==0)
        //setTurnRadarRightRadians(2*Math.PI);
        scanned = true;
    }
    
    static double[] maxValArr;
    public void initKNN()
    {
        maxValArr=new double[_k];
        for (int i=0; i < _k; i++)
        {
            maxValArr[i] = Double.MAX_VALUE;
        }
    }
    public ArrayList<EData> knnNext(int k, EData state)
    {
        LinkedList<EData> eL = el;
        EData c = state;
        ArrayList<EData> knn = new ArrayList<EData>(k);
        double[] nDist = maxValArr.clone();
        double nDistMax = Double.MAX_VALUE;
        int maxIndex = k-1;

        for (EData e : eL)
        {
            if (e.t!=c.t)
            {
                
                double eDist = e.distanceTo(c);
                if (e.getLastDist() < nDistMax)
                {
                    System.out.println(knn.size());
                    EData max = null;
                    if (knn.size() == k)
                    {
                        max = Collections.max(knn);
                        knn.remove(max);
                        
                        //IDK IF THIS IS WHERE THIS SHOULD GO:
                        //nDist[maxIndex] = eDist;
                        //maxIndex = getMaxIndex(nDist);
                        max =Collections.max(knn);
                        nDistMax = max.getLastDist();
                    }
                        
                    knn.add(e);
                    
                    
                }

                


                /* for (int i=0; i < k, i++)
                {
                    if (eDist < nDist[i])
                    {
                        knn[i]=e;
                        nDist = eDist[i];
                    }
                } */

            }
            
        }
        knn.sort(new Comparator<EData>() {
                    
            public int compare(EData d1, EData d2)
            {
                return (int)(d2.getLastDist() - d1.getLastDist());
            }
        });
        return knn;
    }
    
    private int getMaxIndex(double[] arr) {
        double max = Double.MIN_VALUE;
        int mIndex = -1;
        for (int i=0; i < arr.length; i++)
        {
            if (arr[i] > max)
            {
                mIndex = i;
                max = arr[i];
            }
        }
        return mIndex;
    }

    class EData implements Comparable<EData> {
        double x,y,h,v,d,ab,en,b,cwd,cwb,t;//x, y, heading, velocity, energy, bearing, closest wall dist, closest wall bearing, time of data
        double td,wti,ldd,wlh;//time since last decel, wave time to impact, last dodge direction, waves since last hit
        
        double lastDist;
        
        EData(ScannedRobotEvent e, EData p)
        {
            b=e.getBearingRadians();
            h=e.getHeadingRadians();
            v=e.getVelocity();
            d=e.getDistance();
            en=e.getEnergy();
            ab =(b+getHeadingRadians());
            x=_x+Math.sin(ab)*d;
            y=_y+Math.cos(ab)*d;
            t=getTime();
            if (p!=null)
            {

            }
        }

        public double distanceTo(EData other)
        {
            double hw = Math.pow(robocode.util.Utils.normalAbsoluteAngle(h-other.h)/Math.PI/2, 2);
            double vw = Math.pow((v-other.v)/800, 2);
            double tdw = Math.pow((td-other.td)/10000, 2);
            double dw = Math.pow((d-other.d)/10000, 2);

            double eDist = Math.sqrt(hw + vw + tdw + dw);

            lastDist = eDist;

            return eDist;
        }
        public double getLastDist()
        {
            return lastDist;
        }
        @Override
        public int compareTo(EData other)
        {

            return (int)(this.getLastDist() - other.getLastDist());

        }
    }
}
