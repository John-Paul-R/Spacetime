/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package origin;

import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.geom.Point2D;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedList;

import robocode.*;
import robocode.util.Utils;
public class Minigun extends AdvancedRobot {
    
    static LinkedList<EData> el;
    double sd=1;
    boolean scanned = false;
    double _x, _y, _w, _h;
    long _t;
    final static int _k = 2;
    double[] px=new double[_k], py=new double[_k];
    double[][] p = new double[100][2];
    double xx=0, yy=0;
    static double[] maxValArr;

    public void run() {
        setAdjustGunForRobotTurn(true);
		setAdjustRadarForGunTurn(true);
        setTurnRadarRightRadians(4*Math.PI);
        if (getRoundNum()<1)
        {
            el = new LinkedList<EData>();
            initKNN();
        }

        while(true)
        {
            _x=getX();
            _y=getY();
            _w=getBattleFieldWidth();
            _h=getBattleFieldHeight();
            _t=getTime();
            EData c = null;
            if (el.size()>0)
                c=el.getLast();
            if (el.size()>0 && el.size() < 100) {
                //System.out.println("["+getTime()+"] Firing with HOT");
                    //p=el.get(el.size()-2);
                    double a=Utils.normalRelativeAngle(c.ab-getGunHeadingRadians());
                    setTurnGunRightRadians(a);
                setFire(2.1);
            } else if (el.size()>100) {//Begin using knn gun
                //System.out.println("["+getTime()+"] Firing with KNN");
                long t=1;
                EData cState = c;
                ArrayList<EData> cStates = null;
                while (Rules.getBulletSpeed(2.1)*t < Point2D.distance(cState.x, cState.y, _x, _y))//predict into the future far enough (for a given bullet speed)
                {
                    //try {
                    ArrayList<EData> ncStates = knn(_k, cState);
                    int i = 0;
                    int nextIndex = Integer.MAX_VALUE;
                    while (nextIndex >= el.size())
                    {
                        nextIndex = el.indexOf(ncStates.get(i))+1;
                    }
                    {
                        
                        if (ncStates != null)
                        {
                            cStates = ncStates;
                        }
                        cState = new EData(cState, ncStates.get(0), el.get(nextIndex));
                        xx = cState.x;
                        yy = cState.y;
                        //System.out.println("TEST");
                        if (t <= 100)
                        p[(int)t-1] = new double[] {xx, yy};
                    }
                        
                        //cState = ;
                    //} catch (Exception e)
                    //{
                    //    System.out.println("["+getTime()+"] Hit list time boundary.");
                    //}
                    
                    t++;
                    //System.out.println(t);

                }
                //cStates = knn(_k, cState);
                
                for (int i=0; i < _k; i++)
                {
                    if (cStates != null)
                    {
                        EData cS = null;
                        EData c1 = cStates.get(i);
                        int nIndex = el.indexOf(c1)+1;
                        if (nIndex < el.size())
                        {
                            cS = new EData(cState, c1, el.get(el.indexOf(c1)+1));
                            px[i]=cS.x;
                            py[i]=cS.y;
                        }
                        
                        //System.out.println("test");
                    }
                }
                double a=Utils.normalRelativeAngle(Math.atan2(cState.x-_x, cState.y-_y)-getGunHeadingRadians());
                setTurnGunRightRadians(a);
            }
            //System.out.println(c);
            if (!scanned)
            {
                System.out.println("Not scanned on turn " + getTime() +"!");
                setTurnGunRight(Rules.GUN_TURN_RATE);
                setTurnRadarRight(Rules.RADAR_TURN_RATE);
                setTurnRight(Rules.MAX_TURN_RATE);
            }
                
            scanned = false;
            setFire(2.1);
           execute();
        }
    }
    
    public void onPaint(Graphics2D g) {
        g.setColor(Color.RED);
        for (int i=0; i < _k; i++)
        {
            g.drawOval((int)px[i]-18, (int)py[i]-18, 36, 36);

        }
        g.setColor(Color.GREEN);
        g.drawOval((int)xx-18, (int)yy-18, 36, 36);

        int size = 10;
        int hsize = size / 2;
        g.setColor(Color.WHITE);
        for (int i=0; i < p.length; i++)
        {
            g.fillOval((int)p[i][0]-hsize, (int)p[i][1]-hsize, size, size);

        }
    }

    public void onScannedRobot(ScannedRobotEvent e) {
        if(el.size()>0) {
            el.add(new EData(e, el.getLast()));
        } else {
            el.add(new EData(e, null));
        }
        sd*=-1;
        double an = Utils.normalRelativeAngle(el.getLast().ab-getRadarHeadingRadians());
        setTurnRadarRightRadians(an+Math.signum(an)*Math.PI/8);
        //if (an==0)
        //setTurnRadarRightRadians(2*Math.PI);
        scanned = true;
    }

    public void initKNN() {
        maxValArr=new double[_k];
        for (int i=0; i < _k; i++)
        {
            maxValArr[i] = Double.MAX_VALUE;
        }
    }
    
    public ArrayList<EData> knn(int k, EData state) {
        LinkedList<EData> eL = el;
        EData c = state;
        ArrayList<EData> knn = new ArrayList<EData>(k);
        double[] nDist = maxValArr.clone();
        double nDistMax = Double.MAX_VALUE;
        int maxIndex = k-1;

        for (EData e : eL)
        {
            if (e.t!=c.t)
            {
                
                double eDist = e.distanceTo(c);
                if (e.getLastDist() < nDistMax)
                {
                    //System.out.println(knn.size());
                    EData max = null;
                    if (knn.size() == k)
                    {
                        max = Collections.max(knn);
                        knn.remove(max);
                        
                        //IDK IF THIS IS WHERE THIS SHOULD GO:
                        //nDist[maxIndex] = eDist;
                        //maxIndex = getMaxIndex(nDist);
                        max =Collections.max(knn);
                        nDistMax = max.getLastDist();
                    }
                        
                    knn.add(e);
                    
                    
                }

                


                /* for (int i=0; i < k, i++)
                {
                    if (eDist < nDist[i])
                    {
                        knn[i]=e;
                        nDist = eDist[i];
                    }
                } */

            }
            
        }
        knn.sort(new Comparator<EData>() {
                    
            public int compare(EData d1, EData d2)
            {
                return (int)(d2.getLastDist() - d1.getLastDist());
            }
        });
        return knn;
    }
    
    private int getMaxIndex(double[] arr) {
        double max = Double.MIN_VALUE;
        int mIndex = -1;
        for (int i=0; i < arr.length; i++)
        {
            if (arr[i] > max)
            {
                mIndex = i;
                max = arr[i];
            }
        }
        return mIndex;
    }

    class EData implements Comparable<EData> {
        double x,y,h,v,d,ab,en,b,cwd,cwb,t;//x, y, heading, velocity, energy, bearing, closest wall dist, closest wall bearing, time of data
        double td,wti,ldd,wlh;//time since last decel, wave time to impact, last dodge direction, waves since last hit
        
        double lastDist;
        
        EData(ScannedRobotEvent e, EData p)
        {
            b=e.getBearingRadians();
            h=e.getHeadingRadians();
            v=e.getVelocity();
            d=e.getDistance();
            en=e.getEnergy();
            ab =(b+getHeadingRadians());
            x=_x+Math.sin(ab)*d;
            y=_y+Math.cos(ab)*d;
            t=getTime();
            if (p!=null)
            {

            }
        }
        EData(EData start, EData nearest, EData next)
        {
            double[] a = start.getDataArr();
            double[] b = nearest.getDataArr();
            double[] c = next.getDataArr();
            
            



            this.b= a[0]+(c[0]-b[0]);
            h=      robocode.util.Utils.normalRelativeAngle(a[1]+(c[1]-b[1]));
            v=      a[2]+(c[2]-b[2]);
            d=      a[3]+(c[3]-b[3]);
            en=     a[4]+(c[4]-b[4]);
            ab=     a[5]+(c[5]-b[5]);
            x=      (c[6]-b[6]);
            y=      (c[7]-b[7]);
            
            t=      a[8]+(c[8]-b[8]);
            double distTraveled = Math.sqrt(x*x + y*y);
            double travelDirection = Math.atan2(x, y);
            x = a[6]+(distTraveled * Math.sin(travelDirection - b[1] + h));
            y = a[7]+(distTraveled * Math.cos(travelDirection - b[1] + h));
        }
        public double[] getDataArr()
        {
            return new double[] {b,h,v,d,en,ab,x,y,t};
        }
        public double distanceTo(EData other)
        {
            double hw = Math.pow(robocode.util.Utils.normalAbsoluteAngle(h-other.h)/Math.PI/2/10, 2);
            double vw = Math.pow((v-other.v)/800, 2);
            double tdw = Math.pow((td-other.td)/10000, 2);
            double dw = Math.pow((d-other.d)/10000, 2);

            double eDist = Math.sqrt(hw + vw + tdw + dw);

            lastDist = eDist;

            return eDist;
        }
        public double getLastDist()
        {
            return lastDist;
        }
        @Override
        public int compareTo(EData other)
        {

            return (int)(this.getLastDist() - other.getLastDist());

        }
    }
}
